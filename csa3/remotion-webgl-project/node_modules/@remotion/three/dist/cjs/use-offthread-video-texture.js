"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useInnerVideoTexture = void 0;
exports.useOffthreadVideoTexture = useOffthreadVideoTexture;
const react_1 = require("react");
const remotion_1 = require("remotion");
const no_react_1 = require("remotion/no-react");
const useInnerVideoTexture = ({ playbackRate, src, transparent, toneMapped, }) => {
    const frame = (0, remotion_1.useCurrentFrame)();
    const { fps } = (0, remotion_1.useVideoConfig)();
    const mediaStartsAt = remotion_1.Internals.useMediaStartsAt();
    const currentTime = (0, react_1.useMemo)(() => {
        return (no_react_1.NoReactInternals.getExpectedMediaFrameUncorrected({
            frame,
            playbackRate,
            startFrom: -mediaStartsAt,
        }) / fps);
    }, [frame, playbackRate, mediaStartsAt, fps]);
    const offthreadVideoFrameSrc = (0, react_1.useMemo)(() => {
        return no_react_1.NoReactInternals.getOffthreadVideoSource({
            currentTime,
            src,
            transparent,
            toneMapped,
        });
    }, [toneMapped, currentTime, src, transparent]);
    const [textLoaderPromise] = (0, react_1.useState)(() => Promise.resolve().then(() => __importStar(require('three/src/loaders/TextureLoader.js'))));
    const [imageTexture, setImageTexture] = (0, react_1.useState)(null);
    const fetchTexture = (0, react_1.useCallback)(() => {
        const imageTextureHandle = (0, remotion_1.delayRender)('fetch offthread video frame');
        let textureLoaded = null;
        let cleanedUp = false;
        textLoaderPromise.then((loader) => {
            new loader.TextureLoader()
                .loadAsync(offthreadVideoFrameSrc)
                .then((texture) => {
                textureLoaded = texture;
                if (cleanedUp) {
                    return;
                }
                setImageTexture(texture);
                (0, remotion_1.continueRender)(imageTextureHandle);
            })
                .catch((err) => {
                (0, remotion_1.cancelRender)(err);
            });
        });
        return () => {
            cleanedUp = true;
            textureLoaded === null || textureLoaded === void 0 ? void 0 : textureLoaded.dispose();
            (0, remotion_1.continueRender)(imageTextureHandle);
        };
    }, [offthreadVideoFrameSrc, textLoaderPromise]);
    (0, react_1.useLayoutEffect)(() => {
        const cleanup = fetchTexture();
        return () => {
            cleanup();
        };
    }, [offthreadVideoFrameSrc, fetchTexture]);
    return imageTexture;
};
exports.useInnerVideoTexture = useInnerVideoTexture;
/**
 * @description Allows you to use a video in React Three Fiber that is synchronized with Remotion's `useCurrentFrame()` using the `<OffthreadVideo>`.
 * @see [Documentation](https://remotion.dev/docs/use-offthread-video-texture)
 * @param {UseOffthreadVideoTextureOptions} options Configuration options including the video source (`src`), playback rate (`playbackRate`), transparency (`transparent`), and tone mapping (`toneMapped`).
 * @returns {THREE.Texture | null} A THREE.Texture if available, otherwise null. To be used as a texture in 3D objects in React Three Fiber.
 */
function useOffthreadVideoTexture({ src, playbackRate = 1, transparent = false, toneMapped = true, }) {
    if (!src) {
        throw new Error('src must be provided to useOffthreadVideoTexture');
    }
    const { isRendering } = (0, remotion_1.getRemotionEnvironment)();
    if (!isRendering) {
        throw new Error('useOffthreadVideoTexture() can only be used during rendering. Use getRemotionEnvironment().isRendering to render it conditionally.');
    }
    return (0, exports.useInnerVideoTexture)({ playbackRate, src, transparent, toneMapped });
}
